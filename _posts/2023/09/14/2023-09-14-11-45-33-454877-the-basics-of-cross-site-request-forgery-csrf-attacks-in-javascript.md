---
layout: post
title: "The basics of Cross-Site Request Forgery (CSRF) attacks in JavaScript"
description: " "
date: 2023-09-14
tags: [websecurity, CSRFattacks]
comments: true
share: true
---

Cross-Site Request Forgery (CSRF) attacks are a type of security vulnerability that can compromise the integrity and privacy of web applications. This attack occurs when an attacker tricks a user's browser into making unintended and unauthorized requests to a target website on behalf of the user. In this blog post, we will explore the basics of CSRF attacks in JavaScript and discuss measures to mitigate them.

## How CSRF Attacks Work

1. **User Authentication**: When a user logs into a website, the website sets a session cookie in the user's browser to identify the user for subsequent requests.

2. **Malicious Website**: The attacker crafts a malicious website that contains a form or script targeting a specific action on the target website (e.g., changing email, deleting data, etc.).

3. **User Interaction**: The attacker lures the user to visit the malicious website while they are authenticated on the target website.

4. **Unauthorized Request**: The malicious website automatically submits a form or makes an AJAX request to the target website, using the user's authenticated session cookie.

5. **User Unawareness**: Since the request is sent from the user's browser, the target website considers it legitimate and executes the unauthorized action, unbeknownst to the user.

## Preventing CSRF Attacks

### 1. CSRF Tokens

To defend against CSRF attacks, one common approach is to use CSRF tokens. These tokens are unique values generated by the server and included in forms or requests originating from the website.

By validating the token on the server-side for each request, the website can verify that the request is legitimate and reject any requests without a valid CSRF token.

Example implementation in JavaScript using Express.js:

```javascript
// Generating CSRF token and including it in the response
app.get('/login', (req, res) => {
  const csrfToken = generateCSRFToken();
  res.cookie('csrfToken', csrfToken);
  res.render('login', { csrfToken });
});

// Server-side validation of the CSRF token before processing the request
app.post('/profile', (req, res) => {
  const { csrfToken, email } = req.body;

  if (csrfToken !== req.cookies.csrfToken) {
    // Invalid CSRF token, reject the request
    return res.status(403).send('Invalid CSRF token');
  }

  // Process the request if the CSRF token is valid
  // ...
});
```

### 2. SameSite Cookies

Another effective measure to mitigate CSRF attacks in modern browsers is to set the `SameSite` attribute on session cookies.

By setting `SameSite` to `strict` or `lax`, the browser will restrict the sending of cookies in cross-site requests, preventing CSRF attacks from unauthorized domains.

Example cookie configuration in JavaScript using `document.cookie`:

```javascript
document.cookie = 'sessionToken=abc123; SameSite=strict';
```

## Conclusion

Understanding the basics of CSRF attacks and implementing proper defenses, such as CSRF tokens and SameSite cookies, is crucial for safeguarding web applications against this security vulnerability. By employing these measures, developers can reduce the risk of CSRF attacks and protect user data and privacy.

#websecurity #CSRFattacks